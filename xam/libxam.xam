

; Registers
_ra_ dq 0

_format:
    push rbp
    mov rbp, rsp
    push r12
    push r13
    push r14
    push r15

    sub rsp, 256
    mov r13, rsp
    xor r15, r15

    mov r12, rdi
    mov r14, rsi

.format_loop:
    movzx rax, byte [r12]
    
    test al, al
    jz .format_done

    cmp al, '%'
    je .format_specifier
    
    mov byte [r13 + r15], al
    inc r12
    inc r15
    jmp .format_loop

.format_specifier:
    inc r12
    movzx rax, byte [r12]

    cmp al, 's'
    je .format_string
    cmp al, 'd'
    je .format_decimal
    
    mov byte [r13 + r15], '%'
    inc r15
    mov byte [r13 + r15], al
    inc r15
    inc r12
    jmp .format_loop

.format_string:
    mov rdi, r14
    call .copy_string
    inc r12
    add r14, 8
    jmp .format_loop

.copy_string:
    push r12
    mov r12, rdi
.copy_string_loop:
    movzx rax, byte [r12]
    test al, al
    jz .copy_string_done
    mov byte [r13 + r15], al
    inc r12
    inc r15
    jmp .copy_string_loop
.copy_string_done:
    pop r12
    ret

.format_decimal:
    mov rdi, r14
    mov rsi, r13
    add rsi, r15
    call .int_to_string
    add r15, rax
    inc r12
    add r14, 8
    jmp .format_loop

.int_to_string:
    push rbx
    push rcx
    
    test rdi, rdi
    jnz .int_convert_loop
    mov byte [rsi], '0'
    mov rax, 1
    jmp .int_done

.int_convert_loop:
    xor rcx, rcx
    mov rax, rdi
    mov rbx, 10

.digit_loop:
    xor rdx, rdx
    div rbx
    add dl, '0'
    push rdx
    inc rcx
    test rax, rax
    jnz .digit_loop

    mov rdx, rcx
.write_digits:
    pop rax
    mov byte [rsi], al
    inc rsi
    loop .write_digits

    mov rax, rdx
.int_done:
    pop rcx
    pop rbx
    ret

.format_done:
    mov byte [r13 + r15], 0

    mov rax, r13

    add rsp, 256
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    ret

; TODO: LIBC Alternative printf implementation
; args = _format! 

; Simple wrapper around syscall 
; rdi = exit code 
exit: 
    mov rax, 60
    cmp rdi, 255
    jg .exit_error 
    cmp rdi, 0 
    jl .exit_error 
    syscall 
    
.exit_error:
    mov rax, -1
    ret


macro ccall proc,[arg] { 
    common
    local size
    size = 0
    mov ebp,esp
    if ~ arg eq
    forward
     size = size + 4
    common
     sub esp,size
     end if
     and esp,-16
     if ~ arg eq
     add esp,size
    reverse
     pushd arg
    common
     end if
     call proc
     mov esp,ebp 
}

; Usage: ccall proc_name, [arg1, arg2, ...]
macro ccall proc,[args]
{
    local arg_count, shadow_space, stack_size, align_size
    
    arg_count = 0
    
    if ~ args eq
        forward
            arg_count = arg_count + 1
        common
    end if
    
    shadow_space = 32
    
    if arg_count > 4
        stack_size = (arg_count - 4) * 8 + shadow_space
    else
        stack_size = shadow_space
    end if
    
    align_size = (16 - (stack_size mod 16)) and 15
    stack_size = stack_size + align_size
    
    push rbp
    mov rbp, rsp
    
    sub rsp, stack_size
    
    if arg_count > 0
        mov rcx, args
    end if
    if arg_count > 1
        forward
            if @# = 2
                mov rdx, args
            end if
        common
    end if
    if arg_count > 2
        forward
            if @# = 3
                mov r8, args
            end if
        common
    end if
    if arg_count > 3
        forward
            if @# = 4
                mov r9, args
            end if
        common
    end if
    
    if arg_count > 4
        forward
            if @# > 4
                mov [rsp + shadow_space + (@# - 5) * 8], args
            end if
        common
    end if
    
    call proc
    
    mov rsp, rbp
    pop rbp
}



